# Unit 2

## Slide 1

```markdown
---
*Slide 1*
---

# Physical and Data Link Layer
```

## Slide 2

```markdown
---
*Slide 1*
---

# Physical layer

---
*End of Document*
---
```

## Slide 3

```markdown
---
*Slide 1*
---

# Transmission Media

- Communication Media
  - Wired/Guided
    - Twisted pair
    - Coaxial Cable
    - Optical fibers
  - Wireless/Unguided
    - Radiowaves
    - Microwave
    - Infrared

> *Visual Explanation:*
> - Diagram shows the classification of communication media into wired/guided and wireless/unguided categories.
> - Wired includes twisted pair, coaxial cable, and optical fibers.
> - Wireless includes radiowaves, microwave, and infrared.
```

## Slide 4

```markdown
---
*Slide 1*
---

# Transmission media

- Guided media
    - Guided media provide a connection from one device to another device.
    - It includes twisted-pair cable, coaxial cable, and fiber-optic cable.
- Unguided media
    - Unguided media transport electromagnetic waves without using physical conductor.
- Twisted-pair cable
    - A twisted pair consists of two insulated copper wires, about 1mm thick.
    - The wires are twisted together in helical form, just like your DNA molecule.

> *Visual Explanation:*
> - Diagram of twisted-pair cable showing:
>   - Outer insulator or PVC
>   - Solid copper conductors
```

## Slide 5

```markdown
---
*Slide 1*
---

# Transmission media

- One wire is used to carry signals to the receiver.
- Other is used only as a ground reference. Receiver uses difference between two wire.
- Interference may affect both wires and create unwanted signals.
- E.g. in straight cable noise on both wire are different so it may create difference on receiver.
- By twisting a pair balance is maintained. (in one twist one wire is closer to noise source and other is farther, but in next twist the reverse is true.)
```

## Slide 6

```markdown
---
*Slide 1*
---

# Transmission Media

> *Visual Explanation:*
> - Diagram shows a transmission line with a sender and receiver.
> - Noise source affects the transmission.
> - Noise effect on the upper line is 16 units.
> - Noise effect on the lower line is 12 units.
> - Total effect calculation: 16 - 12 = 4

---
*End of Document*
---
```

## Slide 7

```markdown
---
*Slide 1*
---

# Transmission Media

> *Visual Explanation:*
> - Diagram shows a transmission path from Sender to Receiver.
> - Noise source affects the transmission.
> - Arrows indicate data flow direction with values (4, 3).
> - Total effect calculation: 14 - 14 = 0, indicating no net loss.

---
*End of Document*
---
```

## Slide 8

```markdown
---
*Slide 1*
---

# Transmission media

- Types of twisted pair
    - Shielded twisted pair cable
    - Unshielded twisted pair cable

- **Shielded twisted pair cable**

> *Visual Explanation:*
> - Diagram of a shielded twisted pair cable
> - Components:
>   - Plastic cover
>   - Metal shield
>   - Insulation
>   - Copper
```

## Slide 9

```markdown
---
*Slide 1*
---

# Transmission media

- Unshielded twisted pair cable

> *Visual Explanation:*
> - Diagram of a cable with a plastic cover
> - Contains twisted pairs (5 pairs)
```

## Slide 10

```markdown
---
*Slide 1*
---

# Transmission media

- **Categories of unshielded twisted pair cable**
    - Total seven categories of unshielded twisted pair cable are available

> *Visual Explanation:*
> - Diagram (a): category-3 UTP
> - Diagram (b): category-5 UTP

---
*End of Document*
---
```

## Slide 11

```markdown
---
*Slide 1*
---

# Transmission Media

- **Categories of unshielded twisted pair cable**
    - Total seven categories of unshielded twisted pair cable are available in which 1 as lowest and 7 as highest.
    - (a) category-3 UTP
    - (b) category-5 UTP
- **Connectors**
    - Most common UTP connector is RJ45.

> *Visual Explanation:*
> - Illustration of twisted pair cables and RJ45 connectors.
> - Diagrams showing 4-conductor, 6-conductor, and 8-conductor configurations.
```

## Slide 12

```markdown
---
*Slide 1*
---

# Transmission media

- **Performance**
    - Twisted pair can pass wide range of frequency.
    - Gauge is a measure of the thickness of the cable.
    - Thick wire provides more bandwidth.
- **Application**
    - Twisted pair cables can be used in telephone line.
    - Local Area Network
        - 10BaseT and 100BaseT twisted pair cables are used for LAN connection.

---
*End of Document*
---
```

## Slide 13

```markdown
---
*Slide 1*
---

# Transmission media

- **Coaxial Cable**
    - Coaxial cable carries signals of higher frequency ranges than those in twisted pair cable.
    - Instead of having two wires, coax has a central core conductor of solid copper.

> *Visual Explanation:*
> - Diagram of a coaxial cable showing:
>   - Plastic cover
>   - Outer conductor (shield)
>   - Insulator
>   - Inner conductor
```

## Slide 14

```markdown
---
*Slide 1*
---

# Transmission Media

- The copper core is enclosed in an insulating sheath.
- Insulating sheath is covered in an outer conductor of metal foil, braid or combination of two.
- Outer conductor is enclosed in insulating sheath.
    - Outer conductor gives protection against noise and protection to the second conductor which completes the circuit.
- And the whole cable is protected by plastic cover.

- Categories of coaxial cable
    - RG-59 – cable TV
    - RG-58 – Thin Ethernet
    - RG-11 – Thick Ethernet

- Coaxial cable connector
    - BNC connector (Bayon-neill connector)
        - Used to connect end of the cable
    - BNCT connector
        - Used in Ethernet networks
    - BNC Terminator
        - Used at the end of the cable to prevent the reflection of the signal.
```

## Slide 15

```markdown
---
*Slide [N]*
---

# Transmission Media

> *Visual Explanation:*
> - Image of various connectors used in transmission media
> - Includes BNC connectors and coaxial cable
> - Used for transmitting signals in networking and broadcasting

---
*End of Document*
---
```

## Slide 16

```markdown
---
*Slide 1*
---

# Transmission media

- Performance
    - Coaxial cable has a much higher bandwidth than the twisted pair.
- Application
    - Telephone lines
    - Cable TV networks
    - Traditional Ethernet network
```

## Slide 17

```markdown
---
*Slide 1*
---

# Transmission media

- **Fiber optic cable**
    - A fiber optic cable is made up of glass or plastic and transmits signals in the form of light.
    - (a) side view of single fiber
    - (b) end view of a sheath with three fiber
- Light travels in a straight line as long as it is moving from a single uniform substance.
- If light moves from one substance to another, the ray changes direction.

> *Visual Explanation:*
> - Diagram (a): Shows the side view of a single fiber with core, cladding, and jacket.
> - Diagram (b): Illustrates the end view of a sheath with three fibers, highlighting the core and cladding arrangement.
```

## Slide 18

```markdown
---
*Slide 1*
---

# Transmission media

- Propagation mode

> *Visual Explanation:*
> - Diagram of transmission modes
> - Hierarchical structure:
>   - Mode
>     - Multimode
>       - Step-index
>       - Graded-index
>     - Single mode

---
*End of Document*
---
```

## Slide 19

```markdown
---
*Slide 1*
---

# Transmission media

- Multimode
    - Multiple beams from a light source move through the core in different paths.
- Single mode
    - Single beam from a light source moves through core.
- Propagation of beams almost horizontal.

> *Visual Explanation:*
> - Diagram shows light propagation in a fiber optic cable.
> - Multimode step-index illustrated with multiple beams reflecting within the core.
> - Source to Destination flow depicted.

---
*End of Document*
---
```

## Slide 20

```markdown
---
*Slide 1*
---

# Transmission media

- Single mode

> *Visual Explanation:*
> - Diagram of a single-mode transmission medium
> - Data flows from Source to Destination
> - Consistent waveform pattern from input to output

---
*End of Document*
---
```

## Slide 21

```markdown
---
*Slide 1*
---

# Transmission Media

- SC connector (Subscribe channel connector)
    - Used for cable TV
- ST connector (Straight tip connector)
    - Connecting cable in networking
- MT-RJ connector same size as RJ45.

> *Visual Explanation:*
> - Image of various connectors including SC and ST types.
```

## Slide 22

```markdown
---
*Slide 1*
---

# Transmission Media

- Applications
    - Often found in backbone network; its wide bandwidth is cost effective
    - Some cable TV companies use a combination of fiber & coaxial cable.
    - Fast Ethernet uses 100baseFX and 1000baseFX fiber optic cable.
- Advantage of fiber optic
    - High bandwidth
        - Fiber optic provides higher bandwidth than twisted pair & coaxial cable.
    - Less Signal attenuation
        - Transmission distance is greater than that of other guided media
        - In twisted pair, repeaters are required at every 5KM.
        - While in fiber optic, repeaters are required at every 50KM.
    - Immunity to electromagnetic interference
        - Electromagnetic noise cannot affect fiber optic cable
    - Resistance to corrosive material
        - Resistance power is more than copper cable
    - Light weight
        - Much lighter than copper
```

## Slide 23

```markdown
---
*Slide [N]*
---

# Transmission media

- Grater immunity to tapping
    - Intruder can not tape fiber optic cable
- Disadvantage
    - Installation and maintenance
        - New technology so that expert engineer is required
    - Unidirectional light propagation
        - If we need bidirectional line than two fibers are needed
    - Cost
        - Cable and interfaces are relatively more expensive
```

## Slide 24

```markdown
---
*Slide 1*
---

# Transmission Media

- Unguided media: Wireless
    - Unguided media transport electromagnetic waves without using physical conductor.
    - Often called wireless communication.
    - Signals are normally broadcast through free space.
    - When electrons (signal) move, they create electromagnetic waves.
    - "Number of cycles per second of electron wave is called its frequency and it is measured in HZ."
    - Electromagnetic spectrum

> *Visual Explanation:*
> - Diagram shows the electromagnetic spectrum with frequency ranges.
> - Includes Radio, Microwave, Infrared, UV, X-ray, Gamma ray.
> - Visible light is highlighted.
> - Lower diagram details specific frequency ranges for communication methods like AM radio, FM radio, TV, Satellite, etc.

---
*End of Document*
---
```

## Slide 25

```markdown
---
*Slide 1*
---

# Transmission Media

- Ranging from 3KHz to 900THz used for wireless communication.

> *Visual Explanation:*
> - Diagram shows the electromagnetic spectrum.
> - Visible light is highlighted within the spectrum.
> - Radio waves and microwaves are on the longer wavelength side.
> - Infrared and light waves are shown with increasing frequency.

---
*End of Document*
---
```

## Slide 26

```markdown
---
*Slide 1*
---

# Transmission media

- Propagation Type

> *Visual Explanation:*
> - Diagram shows three types of propagation:
>   1. Ground propagation (below 2 MHz)
>   2. Sky propagation (2–30 MHz)
>   3. Line-of-sight propagation (above 30 MHz)
> - Each type involves interaction with the ionosphere.
```

## Slide 27

```markdown
---
*Slide 1*
---

# Transmission media

- Ground propagation
    - Radio waves travel through the very lowest portion of the atmosphere.
- Sky Propagation
    - Higher frequency radio waves radiate upward into the ionosphere (waves reflect back).
- Line of sight propagation
    - Very high frequency signals are transmitted in straight lines directly from antenna to antenna.
- **Range of frequency is known as band.**

---
*End of Document*
---
```

## Slide 28

```markdown
---
*Slide 1*
---

# Transmission Media

| Band                        | Range           | Propagation       | Application                                      |
|-----------------------------|-----------------|-------------------|--------------------------------------------------|
| VLF (very low frequency)    | 3–30 kHz        | Ground            | Long-range radio navigation                      |
| LF (low frequency)          | 30–300 kHz      | Ground            | Radio beacons and navigational locators          |
| MF (middle frequency)       | 300 kHz–3 MHz   | Sky               | AM radio                                         |
| HF (high frequency)         | 3–30 MHz        | Sky               | Citizens band (CB), ship/aircraft communication  |
| VHF (very high frequency)   | 30–300 MHz      | Sky and line-of-sight | VHF TV, FM radio                             |
| UHF (ultrahigh frequency)   | 300 MHz–3 GHz   | Line-of-sight     | UHF TV, cellular phones, paging, satellite       |
| SHF (superhigh frequency)   | 3–30 GHz        | Line-of-sight     | Satellite communication                          |
| EHF (extremely high frequency) | 30–300 GHz   | Line-of-sight     | Radar, satellite                                 |

---
*End of Document*
---
```

## Slide 29

```markdown
---
*Slide 1*
---

# Transmission Media

- Wireless Transmission:
  - Radio wave
  - Microwave
  - Infrared

> *Visual Explanation:*
> - Diagram shows hierarchical structure of wireless transmission types.
> - Wireless transmission is divided into three categories: Radio wave, Microwave, and Infrared.
```

## Slide 30

```markdown
---
*Slide 1*
---

# Transmission media

- Radio waves
    - Electromagnetic waves ranging in frequencies between 3KHz and 1GHz are normally called radio waves.
    - Radio waves are omnidirectional.
    - Antenna transmits radio waves, they are propagated in all directions.
    - Sending and receiving antennas do not have to be aligned.

> *Visual Explanation:*
> - Diagram of an omnidirectional antenna showing wave propagation in all directions.
```

## Slide 31

```markdown
---
*Slide 1*
---

# Transmission media

- Radio wave propagate in sky mode.
- It can travel long distances.
- Radio is good for long distance broadcasting.
- Radio waves are of low and medium frequencies.
- It can penetrate walls.

> *Visual Explanation:*
> - Diagram shows two types of wave propagation:
>   1. Ground wave
>   2. Sky wave via ionosphere
> - Ground wave travels along Earth's surface.
> - Sky wave reflects off the ionosphere.
```

## Slide 32

```markdown
---
*Slide 1*
---

# Transmission media

- Applications
    - AM and FM radio
    - Television
    - Maritime radio
    - Cordless phone
- Disadvantage
    - Omnidirectional propagation
```

## Slide 33

```markdown
---
*Slide 1*
---

# Transmission Media

- Microwaves
    - Electromagnetic waves having frequencies between 1 and 300GHz are called microwaves.
    - Microwaves are unidirectional.
    - Sending and receiving antenna need to be aligned.
- Characteristics
    - Microwave propagation is line of sight.
    - Towers need to be very tall.
    - Repeaters are required for long distance communication.
    - Very high frequency microwave can penetrate walls.
    - Bands are relatively wide almost 299GHz.
    - To use band requires permission from authorities.

---
*End of Document*
---
```

## Slide 34

```markdown
---
*Slide 1*
---

# Transmission media

- Unidirectional antennas

- Parabolic dish antenna
    - Every line parallel to line of sight, reflects off the curve at angles such that all lines intersect in common point called the focus.
    - Parabolic dish works as funnel – catching the waves and directing them to common point.

> *Visual Explanation:*
> - Diagram shows a dish antenna focusing waves to a point.
> - Horn antenna directs waves through a waveguide.
```

## Slide 35

```markdown
---
*Slide 1*
---

# Transmission media

- Horn antenna
    - Looks like gigantic scoop.
    - Outgoing transmissions are broadcast up a stem and deflected upward in a series of narrow parallel beams by the curved head.
- Application
    - Cellular phone
    - Satellite networks
    - Wireless LANs
```

## Slide 36

```markdown
---
*Slide 1*
---

# Transmission media

- Infrared waves
    - Infrared signals can be used for short range communication in a closed area using line of sight propagation.
    - Frequencies from 300GHz to 400THz.
    - Wavelength from 1mm to 770mm.
    - Cannot be used outside the building.
    - Eg. TV remote
- Applications
    - Transmit digital data at very high rate.
    - IrDA (Infrared Data Association) sponsors the use of infrared waves for communication between devices like keyboard, mice, PCs and printers.
    - Some manufacturers provide IrDA port that allow communication between wireless keyboard and PC.
```

## Slide 37

```markdown
---
*Slide 1*
---

# Data Link Layer

---
*End of Document*
---
```

## Slide 38

```markdown
---
*Slide 1*
---

# Error Detection

- Data can be corrupted during transmission. Some applications require that errors be detected and corrected.
- There are two types of error:
    - Single bit error
    - Burst error
- Single bit error
    - In a single bit error, only 1 bit in the data unit has changed.
    - The least likely type of error in serial data transmission.

> *Visual Explanation:*
> - Diagram shows a single bit error where 0 is changed to 1.

- Burst error
    - A burst error means that 2 or more bits in the data unit have changed.
    - More likely to occur than a single bit error.
```

## Slide 39

```markdown
---
*Slide 1*
---

# Error Detection

- **Error Detection methods**
- *Error Detection* techniques allow detecting such errors,
- *Error correction* enables reconstruction of original data
- Three methods are available
    - Parity check
        - VRC – Vertical Redundancy Check (parity check)
        - LRC - Longitudinal Redundancy Check
    - Checksum
    - CRC – Cyclic Redundancy Check

> *Visual Explanation:*
> - Diagram shows a length of burst error (8 bits) in a sequence.
> - Sent data: 0100010010000011
> - Received data: 0111101100000011
> - Corrupted bits are highlighted.
```

## Slide 40

```markdown
---
*Slide 1*
---

# Parity bits

- There are two variants of parity bits:
    - Even parity bit
    - Odd parity bit
- When using even parity, the parity bit is set to 1 if the number of ones in a given set of bits (not including parity bit) is odd, making the number of ones in the entire set of bits (including the parity bit) even.
- If the number of one bits is already even, it is set to a 0.
    - 0110011 -> 01100110
    - 0111011 -> 01110111
- Odd parity
    - When using odd parity, the parity bit is set to 1 if the number of ones in a given set of bits (not including the parity bit) is even, keeping the number of ones in the entire set of bits (including the parity bit) odd.
    - And when the number of set bits is already odd, parity bit is set to 0.
        - 0110011 -> 01100111
        - 0111011 -> 01110110
```

## Slide 41

```markdown
---
*Slide 1*
---

# Vertical Redundancy Check (VRC)

- Appending a single bit at the end of data block such that the number of ones is even.
- Example
    - 0110011 -> 01100110
    - 0111011 -> 01110111
- VRC is known as **parity check**.

---
*End of Document*
---
```

## Slide 42

```markdown
---
*Slide 1*
---

# Longitudinal Redundancy Check (LRC)

- Sender side:
    - Do the modulo addition of the given number (XOR)
    - Attach calculated LRC answer with data.
    - Send the combined data.
- Receiver side:
    - Do modulo addition of all the numbers without including LRC.
    - Compare calculated data with LRC.
    - If both are same, then it is assumed no error otherwise there is an error.
- Organize data into a table and create a parity for each column

> *Visual Explanation:*
> - Data is organized into a table.
> - Parity is calculated for each column.
> - LRC is appended to the original data.
```

## Slide 43

```markdown
---
*Slide 1*
---

# Checksum

- Sender side:
    - Do the addition of the given numbers
    - Do the 1’s complement of the result
    - Attach calculated 1’s complemented answer with data.
    - Send the combined data.
- Receiver side:
    - Do addition of all the numbers including the checksum.
    - Calculate 1’s complement of answer.
    - If result is 0 then it assumes no error otherwise there is an error.
```

## Slide 44

```markdown
---
*Slide 1*
---

# Checksum

- Original Data: `11100111 11011101 00111001 10101001`
- Checksum Calculation:
  - Data segments:
    - `11100111`
    - `11011101`
    - `00111001`
    - `10101001`
  - Checksum result: `10101010`

> *Visual Explanation:*
> - Data segments are summed to produce the checksum.
> - The checksum is appended to the original data for error checking.
```

## Slide 45

```markdown
---
*Slide 1*
---

# Cyclic Redundancy Check (CRC)

- It is also known as polynomial code.
- Cyclic Redundancy Check
    - Bit Stream M(x)
    - Generator Polynomial G(x)
- Steps to do CRC
    - Let r be the degree of G(x), append r zero to lower order end of the frame, so m+r bits.
    - Divide the lower order bit stream by G(x)
    - Add the reminder to the lower order bit stream.
    - Transmit the data.
- Eg. Frame 1101011011 using the generator
    - G(x)=X^4+X+1
- Sender side
    - M(x)=110011 -> X^5+X^4+X+1 (6bits)
    - G(x)=11001 -> X^4+X^3+1 (5 bits, r=4)
        - 4 bits of redundancy
    - From M(x) -> 1100110000 divide M(x) by G(x) to find C(x).

---
*End of Document*
---
```

## Slide 46

```markdown
---
*Slide [N]*
---

# CRC Calculation

- Frame: 1101011011
- Generator: 10011
- Message after 4 zero bits are appended: 11010110110000

> *Process Flow:*
> 1. Initial division of the message by the generator
> 2. Perform bitwise XOR operation
> 3. Shift and repeat until completion
> 4. Remainder: 1110

- Transmitted frame: 11010110111110

> *Visual Explanation:*
> - The diagram illustrates the step-by-step division process
> - Shows how the remainder is calculated and appended
```

## Slide 47

```markdown
---
*Slide 1*
---

# Framing

- The data link layer needs to pack bits into frames, so that each frame is distinguishable from another.
- "Framing separates the messages by adding a sender address and receiver address."
- Message could be packed in a frame.
- When a message is carried in one large frame, even a single bit error would require retransmission of the whole message.
- Frame format.

> *Visual Explanation:*
> - Diagram shows a frame structure with three main components: Header, Payload field, and Trailer.
> - Header includes: Sender Address, Receiver Address, Sequence number, etc.
> - Trailer includes: Error detection and correction mechanism.
> - Payload field labeled as DATA.
```

## Slide 48

```markdown
---
*Slide 1*
---

# Framing

- There are two types of framing
    - Fixed size framing
        - No need to define boundaries of the frames, the size itself can be used as a delimiter.
    - Variable size framing
        - We need to define the end of the frame and beginning of the next.
- Framing techniques
    - Character oriented approach
        - Character count
        - Byte stuffing
    - Bit oriented approach
        - Bit stuffing
- **Character count**

> *Visual Explanation:*
> - Diagram shows data structure with flags, header, variable number of characters, and trailer.
> - Data to be carried are 8-bit characters.

---
*End of Document*
---
```

## Slide 49

```markdown
---
*Slide 1*
---

# Character Count

- **Header**: carries the source and destination address and other control information.
- **Trailer**: which carries error detection and error correction redundant bits, are multiples of 8 bits.
- **Flag**: flag is added at beginning and ending of the frame to separate one frame from the next.
    - The flag composed of protocol dependent special character that signals the start or end of the frame.
- **Problem with character count**
    - It is popular when only text was exchanged by the data link layer.
    - This technique is not used, if we send other types of information such as graph, audio and video.
    - For that byte stuffing strategy was added with character count framing.

---
*End of Document*
---
```

## Slide 50

```markdown
---
*Slide 1*
---

# Byte Stuffing

- A special byte is added to the data section of the frame when there is a character with the same pattern as the flag.
- The data section is stuffed with an extra byte. This byte is usually called the escape character (ESC) which has a predefined bit pattern.
- Whenever the receiver encounters the ESC character, it removes it from the data section and treats the next character as data.
- **Byte stuffing is the process of adding 1 extra byte whenever there is a flag or escape character in the text.**
- Problem with byte stuffing.
    - If text contains one or more escape characters followed by a flag, the receiver removes the escape character but keeps the flag, which is incorrectly interpreted as the end of the frame.
- Solution to this problem.
    - The escape character that is part of the text must also be marked by another escape character.

---
*End of Document*
---
```

## Slide 51

```markdown
---
*Slide [N]*
---

# Data Transmission Process

- Frame Structure:
  - Flags at both ends
  - Header and Trailer sections
  - ESC sequences for data integrity

> *Process Flow:*
> 1. Data from upper layer is framed with Flags and ESC.
> 2. Frame sent with additional ESC for stuffing.
> 3. Frame received and unstuffed to original data.
> 4. Data delivered to upper layer.

> *Visual Explanation:*
> - Data flow is bidirectional.
> - Extra bytes added for stuffing.
> - Unstuffing restores original data.

---
*End of Document*
---
```

## Slide 52

```markdown
---
*Slide 1*
---

# Bit Stuffing

- The data section of a frame is a sequence of bits to be interpreted by the upper layer as text, graphics, audio, video and so on.
- We still need a delimiter to separate one frame from the other. Most protocols use a special 8-bit pattern flag 01111110 as the delimiter to define the beginning and the end of the frame.
- This flag can create the same problem we saw in the byte-oriented protocols; that is, if the flag pattern appears in the data, we need to inform the receiver that this is not the end of the frame.
- We do it by stuffing 1 single bit (instead of 1 byte) to prevent the pattern from looking like a flag. This strategy is called bit stuffing.

> *Visual Explanation:*
> - Diagram shows the structure of a frame with a header, data, and trailer.
> - Flags (01111110) mark the start and end of the frame.
> - Data from the upper layer is encapsulated between header and trailer.
```

## Slide 53

```markdown
---
*Slide 1*
---

# Bit Stuffing

- Bit stuffing is the process of adding one extra 0 whenever five consecutive 1s follow a 0 in the data, so that the receiver does not mistake the pattern 0111110 for a flag.

> *Visual Explanation:*
> - Data from upper layer is stuffed with extra 0s.
> - Frame sent includes a header, stuffed data, and a trailer.
> - Frame received is unstuffed to retrieve original data.
> - Arrows indicate the flow of data from upper layer to frame and back.

---
*End of Document*
---
```

## Slide 54

```markdown
---
*Slide 1*
---

# Flow Control & Error Control

- The most important responsibility of data link layer are flow control and error control. Collectively, these functions are known as data link control.

> Note: 
> Flow control refers to a set of procedures used to restrict the amount of data that the sender can send before waiting for acknowledgment.

- Any time an error is detected in an exchange, specified frames are retransmitted. This process is called **Automatic Repeat Request**.

> Note: 
> Error control in the data link layer is based on automatic repeat request, which is the retransmission of data.
```

## Slide 55

```markdown
---
*Slide 1*
---

# Protocols

- Now let us see how the data link layer can combine framing, flow control, and error control to achieve the delivery of data from one node to another.
- The protocols are normally implemented in software by using one of the common programming languages.
- To make our discussion language free, we have written in pseudo code a version of protocol that concentrates mostly on the procedure instead of delving into details of language rules.

> *Visual Explanation:*
> - Diagram of Protocols
> - For noiseless channel:
>   - Simplest
>   - Stop-and-Wait
> - For noisy channel:
>   - Stop-and-Wait ARQ
>   - Go-Back-N ARQ
>   - Selective Repeat ARQ
```

## Slide 56

```markdown
---
*Slide 1*
---

# Noiseless channels

- Let us first assume we have an ideal channel in which no frames are lost, duplicated or corrupted. We introduce two protocols for this type of channel.
- Two types:
    - Simplest protocol
    - Stop-and-wait protocol.
```

## Slide 57

```markdown
---
*Slide 1*
---

# Simplest Protocol

- Named simplest protocol because it has no flow or no error control.
- It is a unidirectional protocol in which data frames travel in one direction.
- Receiver can never be overwhelmed with incoming frames.
    - Receiver can immediately handle any frame it receives with negligible time.
- Design
    - The data link layer at the sender side gets data from its network layer, makes a frame out of the data, and sends it.
    - The data link layer at the receiver side receives a frame from its physical layer, extracts data from the frame, and delivers it to its network layers.
    - Two events:
        - Procedure at sender side:
            - There is no action until there is a request from the network layer.
        - Procedure at receiver side:
            - No action until notification from the physical layer arrives.
```

## Slide 58

```markdown
---
*Slide 1*
---

# Simplest Protocol

- The design of the simplest protocol with no flow and error control

> *Process Flow:*
> 1. **Sender**:
>    - Network Layer: Get data
>    - Data Link Layer: Send frame
>    - Physical Layer: Data frames sent
> 2. **Receiver**:
>    - Physical Layer: Receive frame
>    - Data Link Layer: Deliver data
>    - Network Layer: Data received

> *Event Details:*
> - **Sender Event**: Request from network layer
> - **Receiver Event**: Notification from physical layer

> *Algorithm Execution:*
> - **Sender**: Repeat forever - Algorithm for sender site
> - **Receiver**: Repeat forever - Algorithm for receiver site
```

## Slide 59

```markdown
---
*Slide 1*
---

# Simplest Protocol

- **Sender side algorithm for the simplest protocol**
  ```plaintext
  while(true) // Repeat forever
  {
      WaitForEvent(); // Sleep until an event occurs
      if(Event(RequestToSend)) // There is a packet to send
      {
          GetData();
          MakeFrame();
          SendFrame(); // Send the frame
      }
  }
  ```

- **Receiver side algorithm for simplest protocol**
  ```plaintext
  while(true) // Repeat forever
  {
      WaitForEvent(); // Sleep until an event occurs
      if(Event(ArrivalNotification)) // Data frame arrived
      {
          ReceiveFrame();
          ExtractData();
          DeliverData(); // Deliver data to network layer
      }
  }
  ```

---
*End of Document*
---
```

## Slide 60

```markdown
---
*Slide 1*
---

# Simplest Protocol

- Example

> *Process Flow:*
> 1. Sender A sends a request with a frame.
> 2. Frame travels to Receiver B.
> 3. Arrival is noted at Receiver B.
> 4. Process repeats for subsequent frames.

---
*End of Document*
---
```

## Slide 61

```markdown
---
*Slide 1*
---

# Stop – and – wait Protocol

- Name because the sender sends one frame, stop until it receives confirmation from receiver, and then send the next frame.
- ACK frame (token of acknowledgement) in other direction.
- Design of stop – and – wait protocol
    - In this traffic on the forward channel (sender to receiver) and reversed channel.
    - At any time, there is either one data frame on the forward channel or one ACK on the reverse channel.
    - It uses half duplex mode.
```

## Slide 62

```markdown
---
*Slide 1*
---

# Stop-and-Wait Protocol

- Sender:
  - Network Layer: Get data
  - Data Link Layer: Send frame, Receive frame
  - Physical Layer

- Receiver:
  - Network Layer: Deliver data
  - Data Link Layer: Send frame, Receive frame
  - Physical Layer

> *Process Flow:*
> 1. Sender sends data frame to receiver.
> 2. Receiver sends ACK frame back to sender.
> 3. Event: Request from network layer triggers sender algorithm.
> 4. Event: Notification from physical layer triggers receiver algorithm.
> 5. Both sender and receiver algorithms repeat indefinitely.

> *Visual Explanation:*
> - Data frame moves from sender to receiver.
> - ACK frame moves from receiver to sender.
> - Continuous loop of sending and acknowledging frames.
```

## Slide 63

```markdown
---
*Slide 1*
---

# Stop – and – wait Protocol

- Sender-side algorithm for stop – and – wait protocol

```cpp
while(true) // Repeat forever
canSend = true // Allow the first frame to go
{
    WaitForEvent(); // Sleep until an event occurs
    if(Event(RequestToSend) AND canSend)
    {
        GetData();
        MakeFrame();
        SendFrame(); // Send the data frame
        canSend = false; // Cannot send until ACK arrives
    }
    WaitForEvent(); // Sleep until an event occurs
    if(Event(ArrivalNotification)) // An ACK has arrived
    {
        ReceiveFrame(); // Receive the ACK frame
        canSend = true;
    }
}
```
```markdown
> *Code Explanation:*
> - The loop runs indefinitely, allowing continuous operation.
> - `canSend` is initially set to true, permitting the first frame to be sent.
> - The process waits for an event, checking if a request to send is made and if sending is allowed.
> - Upon receiving an acknowledgment, the frame is received, and sending is re-enabled.
```
```markdown
> Note: This protocol ensures reliable data transmission by waiting for an acknowledgment before sending the next frame.
```
```markdown
---
*End of Document*
---
```

## Slide 64

```markdown
---
*Slide 1*
---

# Stop – and – wait Protocol

- Receiver-side algorithm for stop – and – wait protocol

```cpp
while(true) // Repeat forever
{
    WaitForEvent(); // Sleep until an event occurs
    if(Event(ArrivalNotification)) // Data frame arrives
    {
        ReceiveFrame();
        ExtractData();
        Deliver(data); // Deliver data to network layer
        SendFrame(); // Send an ACK frame
    }
}
```
```markdown
> *Visual Explanation:*
> - The algorithm continuously waits for an event.
> - Upon receiving a data frame, it processes and delivers the data.
> - An acknowledgment frame is sent after data delivery.
```
```

## Slide 65

```markdown
---
*Slide 1*
---

# Stop – and – wait Protocol

- *Example*

> *Visual Explanation:*
> - Sender (A) sends a frame to Receiver (B).
> - Receiver (B) sends an acknowledgment (ACK) back to Sender (A).
> - Process repeats for each frame.
> - Time progresses vertically, showing sequential communication.
```

## Slide 66

```markdown
---
*Slide 1*
---

# Noisy Channel

- Although the stop-and-wait protocol gives us an idea of how to add flow control to its predecessor, noiseless channels are nonexistent.
- Three protocols in this section that use error control
    - Stop-and-Wait Automatic Repeat Request
    - Go-Back-N Automatic Repeat Request
    - Selective Repeat Automatic Repeat Request
```

## Slide 67

```markdown
---
*Slide [N]*
---

# Stop – and – Wait Automatic Repeat Request

- It adds simple error control mechanism to the stop – and – wait protocol.
- When frame arrives at the receiver site, it is checked and if corrupted, it is discarded.
- *If receiver does not respond when there is an error, how can the sender know which frame to resend?*
- The sender keeps a copy of the sent frame, at the same time, it starts timer.
- If the timer expires and there is no ACK for sent, the frame is resent, the copy is held, and the timer restarted.

> Note: Error correction in Stop-and-Wait ARQ is done by keeping a copy of the sent frame and retransmitting of the frame when the timer expires.
```

## Slide 68

```markdown
---
*Slide 1*
---

# Stop – and – Wait Automatic Repeat Request

- **Sequence number**
    - A field is added to the data frame to hold sequence number of that frame.
    - If we decide that field is m bit long, the sequence number start from 0 to 2^m-1 and then are repeated.
    - We have used x as a sequence number, we need to use x+1 after that. There is no need for x+2.

> *Note:*
> In Stop-and-Wait ARQ, we use sequence numbers to number the frames. The sequence numbers are based on modulo-2 arithmetic.
```

## Slide 69

```markdown
---
*Slide 1*
---

# Stop – and – Wait Automatic Repeat Request

- Assumes that sender has sent frame number x.
- **Three things can happen.**
    - The frame arrives safe and receiver sends an acknowledgement. The acknowledgement arrives at the sender sites causing the sender to send the next frame numbered x+1.
    - The frame arrives safe and receiver sends an acknowledgment, but acknowledgement is corrupted or lost. The sender resends the frame (number x) after timeout. The receiver can recognize this fact because it expects frame x+1 but x was received.
    - The frame is corrupted or even arrives at the receiver site, the sender resends the frame (number x) after the timeout.
- **Acknowledgement numbers**
    - The acknowledgement numbers always announce the sequence number of next frame expected by receiver.
    - Eg. If frame 0 has arrived safe and sound, the receiver sends an ACK frame with acknowledgement 1 (means frame 1 is expected next) and vice versa.
```

## Slide 70

```markdown
---
*Slide 1*
---

# Stop – and – Wait Automatic Repeat Request

> Note: In Stop-and-Wait ARQ, the acknowledgment number always announces in modulo-2 arithmetic the sequence number of the next frame expected.
```

## Slide 71

```markdown
---
*Slide 1*
---

# Stop – and – Wait Automatic Repeat Request

- *Design of stop – and – wait ARQ protocol*

> *Process Flow:*
> 1. Sender:
>    - Get data from Network layer
>    - Send frame via Data link
>    - Receive frame via Physical layer
> 2. Receiver:
>    - Deliver data to Network layer
>    - Receive frame via Data link
>    - Send frame via Physical layer
> 3. Events:
>    - Request from network layer triggers sender algorithm
>    - Notification from physical layer triggers receiver algorithm
> 4. Sequence:
>    - Data frame sent with sequence number (seqNo)
>    - ACK frame received with acknowledgment number (ackNo)
>    - Time-out event triggers repeat

---
*End of Document*
---
```

## Slide 72

```markdown
---
*Slide 1*
---

# Stop – and – Wait Automatic Repeat Request

- Sender site algorithm for stop – and – wait ARQ

```plaintext
1  S_n = 0;                // Frame 0 should be sent first
2  canSend = true;         // Allow the first request to go
3  while(true)             // Repeat forever
4  {
5      WaitForEvent();     // Sleep until an event occurs
6      if(Event(RequestToSend) AND canSend)
7      {
8          GetData();
9          MakeFrame(S_n); // The seqNo is S_n
10         StoreFrame(S_n);// Keep copy
11         SendFrame(S_n);
12         StartTimer();
13         S_n = S_n + 1;
14         canSend = false;
15     }
16     WaitForEvent();     // Sleep
```
```markdown
> *Note: This code represents the sender site algorithm for the Stop-and-Wait ARQ protocol, illustrating the process of sending frames and handling events.*
```
```markdown
---
*End of Document*
---
```

## Slide 73

```markdown
---
*Slide [N]*
---

# Stop – and – Wait Automatic Repeat Request

- Sender site algorithm for stop – and – wait ARQ

```cpp
if(Event(ArrivalNotification)) // An ACK has arrived
{
    ReceiveFrame(ackNo); // Receive the ACK frame
    if(not corrupted AND ackNo == S_n) // Valid ACK
    {
        Stoptimer(); // Copy is not needed
        PurgeFrame(S_n-1);
        canSend = true;
    }
}

if(Event(TimeOut)) // The timer expired
{
    StartTimer();
    ResendFrame(S_n-1); // Resend a copy check
}
```
```markdown
> *Note: Continued from previous slide*
```
```markdown
---
*End of Document*
---
```

## Slide 74

```markdown
---
*Slide 1*
---

# Stop – and – Wait Automatic Repeat Request

- Receiver site algorithm for stop – and – wait ARQ

```c
Rn = 0; // Frame 0 expected to arrive first
while(true)
{
    WaitForEvent(); // Sleep until an event occurs
    if(Event(ArrivalNotification)) // Data frame arrives
    {
        ReceiveFrame();
        if(corrupted(frame))
            sleep();
        if(seqNo == Rn) // Valid data frame
        {
            ExtractData();
            DeliverData(); // Deliver data
            Rn = Rn + 1;
        }
        SendFrame(Rn); // Send an ACK
    }
}
```
```markdown
> Note: This algorithm handles the reception and acknowledgment of data frames in a stop-and-wait ARQ protocol.
```
```markdown
> Warning: Low confidence extraction - Code comments may not be fully accurate due to image quality.
```
```markdown
> Alert: Possible data inconsistency detected - Ensure sequence numbers are correctly managed.
```
```markdown
> Animation: None detected
```
```markdown
> *End of Document*
---
```

## Slide 75

```markdown
---
*Slide 1*
---

# Stop – and – Wait Automatic Repeat Request

- Example

> *Visual Explanation:*
> - Diagram shows the Stop-and-Wait ARQ process between Sender (A) and Receiver (B).
> - Key components:
>   - Sender sends Frame 0, waits for ACK 1.
>   - If ACK is not received, Frame 0 is resent.
>   - Process repeats for Frame 1.
>   - Lost frames are indicated with a star.
>   - Duplicate frames are discarded.
> - Flow:
>   - Start → Request → Frame sent → ACK received or timeout → Resend if necessary
>   - Time-out restarts the process.
```

## Slide 76

```markdown
---
*Slide 1*
---

# Go Back N ARQ

- To improve the efficiency of transmission, multiple frames must be in transmission while waiting for acknowledgement.
- We need to let more than one frame to keep the channel busy while the sender is waiting for acknowledgement.
- We achieve it by Go Back N ARQ protocol.
- In this protocol we can send several frames before receiving acknowledgement; we keep a copy of these frames until the acknowledgement arrives.
- It includes concepts like
    - Sequence number
    - Sliding window
    - Timer
    - Acknowledgement
    - Resending frame
- **Sequence number**
    - Frames from a sending station are numbered sequentially.
    - We need to include the sequence number of each frame in header, we need to set a limit.
    - If m=4 then sequence number are 0 to 15. then we can repeat sequence.
```

## Slide 77

```markdown
---
*Slide 1*
---

# Go Back N ARQ

- Sequence Numbers: 
  - 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0,1,2,3,4,...15.

> Note: In the Go-Back-N Protocol, the sequence numbers are modulo \(2^m\), where m is the size of the sequence number field in bits.

- **Sliding Window**
    - It is an abstract concept that defines the range of sequence numbers that is the concern of the sender and receiver.
    - The sender and receiver need to deal with only part of possible sequence number.
    - The range which is the concern of the sender is called **sender sliding window**.
    - The range which is the concern of the receiver is called **receiver sliding window**.
    - In each window position, some of these sequence numbers define:
        - Frame that have been sent
        - Frame that can be sent
```

## Slide 78

```markdown
---
*Slide 1*
---

# Go Back N ARQ

- Send window for Go Back N ARQ

> *Visual Explanation:*
> - **Diagram a: Send window before sliding**
>   - **Frames already acknowledged**: 13, 14, 15
>   - **Frames sent, but not acknowledged (outstanding)**: 0 to 7
>   - **Frames that can be sent, but not received from upper layer**: 8 to 14
>   - **Frames that cannot be sent**: 15, 0, 1
>   - **Send window size**: \( S_{\text{size}} = 2^m - 1 \)
> - **Diagram b: Send window after sliding**
>   - **Frames already acknowledged**: 13, 14, 15, 0, 1, 2
>   - **Frames sent, but not acknowledged (outstanding)**: 3 to 7
>   - **Frames that can be sent, but not received from upper layer**: 8 to 15, 0, 1

---
*End of Document*
---
```

## Slide 79

```markdown
---
*Slide 1*
---

# Go Back N ARQ

The send window is an abstract concept defining an imaginary box of size \(2^m - 1\) with three variables: \(S_f\), \(S_n\), and \(S_{size}\).

- The window defines 3 variables:
    - \(S_f\) (Send Window, first outstanding frame)
        - Defines sequence number of first (oldest) outstanding frame.
    - \(S_n\) (send window, next frame to be sent)
        - Holds sequence number that will be assigned to next frame to be sent.
    - \(S_{size}\) (send window, size)
        - Define size of window, which is fixed in our protocol.

> *Note:*
> The send window is an abstract concept defining an imaginary box of size \(2^m - 1\) with three variables: \(S_f\), \(S_n\), and \(S_{size}\).
```

## Slide 80

```markdown
---
*Slide 1*
---

# Go Back N ARQ

- **Receiver window**
    - Receiver window ensures that the correct data frames are received and that the correct acknowledgments are sent.
    - The size of the receiver window is always 1.
    - The receiver is always looking for the arrival of a specific frame.
    - Any frame arriving out of order is discarded and needs to be resent.

> *Visual Explanation:*
> - **Diagram a: Receive window**
>   - Current frame expected: 3
>   - Frames 0 to 2 already received and acknowledged
>   - Frames 4 to 15 cannot be received until the window slides
> - **Diagram b: Window after sliding**
>   - Current frame expected: 4
>   - Frames 0 to 3 already received and acknowledged
>   - Frames 5 to 15 cannot be received until the window slides
```

## Slide 81

```markdown
---
*Slide [N]*
---

# Go Back N ARQ

The receive window is an abstract concept defining an imaginary box of size 1 with one single variable \( R_n \). The window slides when a correct frame has arrived; sliding occurs one slot at a time.

- \( R_n \) (Receive window, next frame expected)
- The receiver window also slides, but only one at a time.
- When correct frame is received, the window slides.
- **Timer**
    - Only 1 timer for each sent frame.
    - The timer for first outstanding frame always expires first.
    - We send all outstanding frames when timer expires.

> *Note:*
> The receive window is an abstract concept defining an imaginary box of size 1 with one single variable \( R_n \). The window slides when a correct frame has arrived; sliding occurs one slot at a time.
```

## Slide 82

```markdown
---
*Slide 1*
---

# Go Back N ARQ

- **Acknowledgment**
    - The receiver sends positive acknowledgment if frame has arrived safe and sound in order.
    - If frame is damaged or out of order, the receiver discards all the frames until it receives the one it is expecting.
    - This causes timer to expire.
- **Resending Frame**
    - When timer expires, resending all the outstanding frames.
    - This process is called Go Back N ARQ.

---
*End of Document*
---
```

## Slide 83

```markdown
---
*Slide 1*
---

# Go Back N ARQ

- Sender:
    - Network Layer: Get data
    - Data Link Layer: Send frame, Receive frame
    - Physical Layer: Interaction with frames
- Receiver:
    - Network Layer: Deliver data
    - Data Link Layer: Receive frame, Send frame
    - Physical Layer: Interaction with frames

> *Process Flow:*
> 1. Sender sends frames sequentially.
> 2. Receiver acknowledges frames.
> 3. If timeout occurs, sender resends frames.

> *Diagram Explanation:*
> - Sequence numbers (seqNo) and acknowledgment numbers (ackNo) are used.
> - Sender maintains a window of outstanding frames.
> - Receiver maintains a window for frames to be received.
> - Continuous cycle of sending and receiving frames.

> Note: Algorithms for sender and receiver sites operate continuously with event-driven actions.
```

## Slide 84

```markdown
---
*Slide 1*
---

# Go Back N ARQ

- Two scenarios depicted:
  - a. Window size < 2^m
  - b. Window size = 2^m

> *Diagram Explanation:*
> - **Scenario a**:
>   - Sender transmits frames 0, 1, 2
>   - Receiver acknowledges frames
>   - Time-out occurs, frame 0 retransmitted
>   - Frame correctly discarded
> - **Scenario b**:
>   - Sender transmits frames 0, 1, 2, 3
>   - Receiver acknowledges frames
>   - Frame 0 retransmitted after time-out
>   - Frame erroneously accepted

> Note: The diagrams illustrate the flow of frames between sender and receiver, highlighting the impact of window size on frame acceptance and retransmission.
```

## Slide 85

```markdown
---
*Slide 1*
---

# Go Back N Sender Algorithm

```plaintext
1  S_w = 2^m - 1;
2  S_f = 0;
3  S_n = 0;
4  
5  while (true)                  // Repeat forever
6  {
7      WaitForEvent();
8      if(Event(RequestToSend))  // A packet to send
9      {
10         if(S_n - S_f >= S_w)  // If window is full
11             Sleep();
12         GetData();
13         MakeFrame(S_n);
14         StoreFrame(S_n);
15         SendFrame(S_n);
16         S_n = S_n + 1;
17         if(timer not running)
18             StartTimer();
19     }
20 }
```
```markdown
> *Code Explanation:*
> - Initializes window size and sequence numbers.
> - Continuously waits for events.
> - Sends data if a request is made and window is not full.
> - Manages frame creation and transmission.
```
```markdown
> Note: This algorithm is part of the sliding window protocol used in networking.
```
```markdown
---
*End of Document*
---
```

## Slide 86

```markdown
---
*Slide 1*
---

# Go Back N Sender Algorithm

```c
if(Event(ArrivalNotification)) //ACK arrives
{
    Receive(ACK);
    if(corrupted(ACK))
        Sleep();
    if((ackNo > S_f) && (ackNo <= S_n)) //If a valid ACK
    While(S_f <= ackNo)
    {
        PurgeFrame(S_f);
        S_f = S_f + 1;
    }
    StopTimer();
}

if(Event(TimeOut)) //The timer expires
{
    StartTimer();
    Temp = S_f;
    while(Temp < S_n)
    {
        SendFrame(S_f);
        S_f = S_f + 1;
    }
}
```
```markdown
> *Code Explanation:*
> - Handles ACK arrival and timeout events
> - Purges frames upon valid ACK
> - Resends frames on timeout
```
```markdown
---
*End of Document*
---
```

## Slide 87

```markdown
---
*Slide 1*
---

# Go Back N Receiver algorithm

```plaintext
1  R_n = 0;
2  while (true)                //Repeat forever
3  {
4      WaitForEvent();
5      if(Event(ArrivalNotification)) //Data frame arrives
6      {
7          Receive(Frame);
8          if(corrupted(Frame))
9              Sleep();
10         if(seqNo == R_n)          //If expected frame
11         {
12             DeliverData();        //Deliver data
13             R_n = R_n + 1;
14             SendACK(R_n);         //Slide window
15         }
16     }
17 }
```
---
*End of Document*
---
```

## Slide 88

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- Go Back N simplifies the process at the receiver site.
    - The receiver keeps track of only one variable, and there is no need to buffer out-of-order frames.
- This protocol is very inefficient for noise link.
- In this higher probability of damage, which means the resending of multiple frames.
- So there is another mechanism that does not resent N frames when just one frame is damaged. Only the damaged frame is resent. This mechanism is called Selective Repeat ARQ.
- **Windows**
    - It uses 2 windows: send window and receive window.
    - The size of the send window is \(2^{m-1}\).
    - The receiver window is the same size as the send window.
    - Eg. M=4, the size of the sequence number is 0-15 but the size of the window is just 8.
    - This protocol uses the same variable as Go Back N.
```

## Slide 89

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- **Send window for Selective Repeat ARQ**
    - Send window, first outstanding frame
    - Send window, next frame to send

> *Diagram Explanation:*
> - Frames already acknowledged
> - Frames sent, but not acknowledged
> - Frames that can be sent
> - Frames that cannot be sent
> - Send window: Sf to Sn
> - Receiver window size: \( S_{\text{size}} = 2^{m-1} \)

- **Receiver window**
    - Size of receiver window is same as the size of send window \((2^{m-1})\).
    - The Selective Repeat protocol allows as many frames as the size of the receiver window to arrive out of order.
```

## Slide 90

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- Kept until there is set of in-order frames to be delivered to the network layer.
    - Because the size of the send window and receive window are same.
- Receive window for Selective Repeat ARQ

> *Visual Explanation:*
> - Diagram shows the receive window with frames 3 to 10.
> - Frames 3 to 9 can be received and stored for later delivery.
> - Frames already received: 13, 14, 15, 0, 1, 2.
> - Frames that cannot be received: 11, 12, 13, 14, 15, 0, 1.
> - Next frame expected: 3.
> - Colored boxes indicate frames already received.
> - Formula: \( R_{\text{size}} = 2^{m-1} \)
```

## Slide 91

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- Design of Selective Repeat ARQ

> *Process Flow:*
> 1. Sender:
>    - Network Layer: Get data
>    - Data Link Layer: Send frame, Receive frame
>    - Physical Layer: Interacts with data frames
> 2. Receiver:
>    - Network Layer: Deliver data
>    - Data Link Layer: Receive frame, Send frame
>    - Physical Layer: Interacts with data frames
> 3. Sequence:
>    - Sender sends data frames with sequence numbers (seqNo)
>    - Receiver sends ACK or NAK with acknowledgment numbers (ackNo or nakNo)
> 4. Events:
>    - Request from network layer
>    - Notification from physical layer
>    - Time-out triggers algorithm execution

> *Visual Explanation:*
> - Sender and Receiver operate in parallel
> - Data frames are managed with sequence numbers
> - ACK/NAK mechanism ensures reliable transmission
```

## Slide 92

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- Window size
    - Why size of the sender and receiver window must be at most half of 2^m.

> *Visual Explanation:*
> - Two diagrams comparing window sizes.
> - Left Diagram (a): Window size = 2^(m-1)
>   - Sender and Receiver windows are aligned.
>   - Frames are correctly discarded upon timeout.
> - Right Diagram (b): Window size > 2^(m-1)
>   - Misalignment in Sender and Receiver windows.
>   - Frames are erroneously accepted.

*Note: Correctly discarded and erroneously accepted frames are highlighted.*
```

## Slide 93

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- Sender side Selective repeat Algorithm

```plaintext
S_w = 2^{m-1};
S_f = 0;
S_n = 0;

while (true) //Repeat forever
{
    WaitForEvent();
    if(Event(RequestToSend)) //There is a packet to send
    {
        if(S_n-S_f >= S_w) //If window is full
            Sleep();
        GetData();
        MakeFrame(S_n);
        StoreFrame(S_n);
        SendFrame(S_n);
        S_n = S_n + 1;
        StartTimer(S_n);
    }
}
```
```markdown
> *Code Explanation:*
> - The algorithm initializes window size and sequence numbers.
> - It continuously waits for an event.
> - If a request to send is detected and the window is not full, it processes the data.
```
```markdown
> Note: This algorithm is used for reliable data transmission.
```
```markdown
---
*End of Document*
---
```

## Slide 94

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- Sender side Selective repeat Algorithm

```plaintext
if(Event(ArrivalNotification)) //ACK arrives
{
    Receive(frame); //Receive ACK or NAK
    if(corrupted(frame))
        Sleep();
    if (FrameType == NAK)
        if (nakNo between Sf and Sn)
        {
            resend(nakNo);
            StartTimer(nakNo);
        }
    if (FrameType == ACK)
        if (ackNo between Sf and Sn)
        {
            while(sf < ackNo)
            {
                Purge(sf);
                StopTimer(sf);
                Sf = Sf + 1;
            }
        }
}
```
```markdown
> Note: This algorithm handles the sender side of the Selective Repeat ARQ protocol, focusing on ACK and NAK processing.
```
```markdown
---
*End of Document*
---
```

## Slide 95

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- Sender side Selective repeat Algorithm

```cpp
if (Event(TimeOut(t))) // The timer expires
{
    StartTimer(t);
    SendFrame(t);
}
```
```

## Slide 96

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- Receiver side Selective repeat Algorithm

```plaintext
1  Rn = 0;
2  NakSent = false;
3  AckNeeded = false;
4  Repeat(for all slots)
5      Marked(slot) = false;
6  
7  while (true) //Repeat forever
8  {
9      WaitForEvent();
10 
11     if(Event(ArrivalNotification)) //Data frame arrives
12     {
13         Receive(Frame);
14         if(corrupted(Frame) && (NOT NakSent))
15         {
16             SendNAK(Rn);
17             NakSent = true;
18             Sleep();
19         }
20         if(seqNo <> Rn) && (NOT NakSent)
21         {
22             SendNAK(Rn);
```

---
*End of Document*
---
```

## Slide 97

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- Receiver side Selective repeat Algorithm

```plaintext
1   R_n = 0;
2   NakSent = false;
3   AckNeeded = false;
4   Repeat(for all slots)
5       Marked(slot) = false;
6   while (true)                      //Repeat forever
7   {
8       WaitForEvent();
9       if(Event(ArrivalNotification)) //Data frame arrives
10      {
11          Receive(Frame);
12          if(corrupted(Frame) && (NOT NakSent))
13          {
14              SendNAK(R_n);
15              NakSent = true;
16              Sleep();
17          }
18          if(seqNo <> R_n) && (NOT NakSent)
19          {
20              SendNAK(R_n);
21          }
22      }
```

---
*End of Document*
---
```

## Slide 98

```markdown
---
*Slide [N]*
---

# Selective Repeat ARQ

- Receiver side Selective repeat Algorithm

```plaintext
23  NakSent = true;
24  if ((seqNo in window)&&(!Marked(seqNo))
25  {
26      StoreFrame(seqNo)
27      Marked(seqNo)= true;
28      while(Marked(R_n))
29      {
30          DeliverData(R_n);
31          Purge(R_n);
32          R_n = R_n + 1;
33          AckNeeded = true;
34      }
35      if(AckNeeded);
36      {
37          SendAck(R_n);
38          AckNeeded = false;
39          NakSent = false;
40      }
41  }
42  }
43  }
44  }
```

---
*End of Document*
---
```

## Slide 99

```markdown
---
*Slide 1*
---

# Selective Repeat ARQ

- Flow diagram for example

> *Process Flow:*
> 1. Sender A sends Frame 0
> 2. Receiver B acknowledges (ACK 1) Frame 0
> 3. Frame 1 is lost
> 4. Sender A resends Frame 1
> 5. Receiver B sends negative acknowledgment (NAK 1) for Frame 1
> 6. Sender A sends Frame 2 and Frame 3
> 7. Receiver B acknowledges (ACK 4) Frames 1, 2, 3

> *Visual Explanation:*
> - Initial state: Sender and Receiver windows are aligned
> - Frame 0 is successfully delivered and acknowledged
> - Frame 1 is lost and requires retransmission
> - Frames 1, 2, and 3 are eventually delivered and acknowledged

---
*End of Document*
---
```

## Slide 100

```markdown
---
*Slide 1*
---

# Multiple Access

> *Process Flow:*
> 1. MA → CSMA
> 2. CSMA → CSMA/CD
> 3. CSMA → CSMA/CA

---
*End of Document*
---
```

## Slide 101

```markdown
---
*Slide 1*
---

# Carrier Sense Multiple Access Protocol – CSMA

- CSMA requires that each station first listen to the medium (or check state of medium) before sending.
- CSMA based on the principle “Sense before transmit” or “Listen before talk”.

> *Key Definition:*
> Protocols in which stations listen for a carrier (i.e., a transmission channel) and act accordingly are called **Carrier Sense Protocol**.

- It can reduce possibility of collision, but it cannot eliminate it.
- Possibility of collision still exists.
    - When a station sends frames, it still takes time for the first bit to reach every station and for every station to send it.
    - A station may sense the medium and find it ideal, but the first bit sent by another station has not yet been received.
```

## Slide 102

```markdown
---
*Slide 1*
---

# Carrier Sense Multiple Access Protocol – CSMA

- Sense/time model of collision in CSMA

> *Visual Explanation:*
> - Diagram shows computers A, B, and Z connected to a network.
> - A's frame is sent at time \( t_1 \).
> - Z's frame is sent at time \( t_2 \).
> - Collision occurs, and a collision signal is sent back to A at \( t_5 \) and to Z at \( t_4 \).
> - The diagram illustrates the timeline of collision detection and signal propagation.

---
*End of Document*
---
```

## Slide 103

```markdown
---
*Slide 1*
---

# Carrier Sense Multiple Access Protocol – CSMA

- Propagation time \( T_p \).

> **This is time needed for a signal to propagate from one end of medium to other.**

- Vulnerable time:
    - It is a propagation time \( T_p \)
    - Time needed for a signal to propagate from one end to other. If other station can transmit during this time, a collision will happen.

> *Visual Explanation:*
> - Diagram shows frame propagation over time.
> - B senses at \( t_1 \), followed by C and D.
> - Vulnerable time equals propagation time.
```

## Slide 104

```markdown
---
*Slide 1*
---

# Carrier Sense Multiple Access Protocol – CSMA

- Persistence method
    - What should a station do if the channel is busy?
    - What should a station do if the channel is ideal?
    - Three methods are available to answer these questions:
        - 1-persistent method
        - Non-persistent method
        - P-persistent method

---
*End of Document*
---
```

## Slide 105

```markdown
---
*Slide 1*
---

# Carrier Sense Multiple Access Protocol – CSMA

- Behavior of three persistent method

> *Visual Explanation:*
> - **Diagram a: 1-persistent**
>   - Continuously sense
>   - Sense and transmit when channel is free
> - **Diagram b: Nonpersistent**
>   - Sense
>   - Wait if busy, then sense again
>   - Transmit when channel is free
> - **Diagram c: p-persistent**
>   - Continuously sense
>   - Probability outcome determines transmission
>   - Transmit in time slots if channel is free
```

## Slide 106

```markdown
---
*Slide 1*
---

# Carrier Sense Multiple Access Protocol – CSMA

- Flow diagram of three persistent methods

> *Process Flow:*
> 1. **1-persistent:**
>    - Check Channel?
>    - If Idle, Station can transmit.
>    - If Busy, wait and check again.
> 
> 2. **Nonpersistent:**
>    - Check Channel?
>    - If Idle, Station can transmit.
>    - If Busy, wait randomly and check again.
> 
> 3. **p-persistent:**
>    - Check Channel?
>    - If Idle, check Probability outcome.
>    - If outcome ≤ P, Station can transmit.
>    - If outcome > P, wait a slot and check again.
>    - If Busy, use back-off process as though collision occurred.
```

## Slide 107

```markdown
---
*Slide 1*
---

# Carrier Sense Multiple Access Protocol – CSMA

- **1- Persistent**
    - If the station finds the line ideal, it sends its frame immediately with probability 1.
    - This channel has the highest chance of collision because:
        - Two or more stations may find the line ideal and send their frames immediately.

- **Non-persistent**
    - If the line is ideal, it sends immediately.
    - If the line is busy, it waits a random amount of time and then senses the line again.
    - It reduces the chance of collision because:
        - It is unlikely that two or more stations will wait the same amount of time and retry to send simultaneously.
    - It reduces the efficiency of the network because:
        - The medium remains ideal when there may be a station with a frame to send.

- **P-persistent**
    - It combines the advantages of the two other methods.
        - It reduces the chance of collision and improves efficiency.
```

